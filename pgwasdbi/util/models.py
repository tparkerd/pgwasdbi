"""An analogous Python class for each table in GWAS database"""

class AutoRepr(object):
  def __repr__(self):
    items = ("%s = %r" % (k, v) for k, v in self.__dict__.items())
    return "<%s: {%s}>" % (self.__class__.__name__, ', '.join(items))

class species(AutoRepr):
  """Species class

  .. _species_class:

  Args:
    shortname (str): *required.*
    binomial (str): *required.*
    subspecies (str):
    variety (str):

  Returns:
    Species: instance of a species

  """
  def __init__(self, shortname, binomial, subspecies, variety):
    self.n = shortname
    self.b = binomial
    self.s = subspecies
    self.v = variety


class population(AutoRepr):
  """Population class

  .. _population_class:

  Args:
    population_name (str): *required.* human-readable name of population (often shorthand)
    population_species (int): references :ref:`species_id <species_class>`

  Returns:
    Population: instance of a population
  """
  def __init__(self, population_name, population_species):
    self.n = population_name
    self.s = population_species


class line(AutoRepr):
  """Line class

  .. _line_class:

  Args:
    line_name (str): *required.* name of line
    line_population (int): *required.* references :ref:`population_id <population_class>`

  Returns:
    Line: instance of a line
  """
  def __init__(self, line_name, line_population):
    self.n = line_name
    self.p = line_population


class chromosome(AutoRepr):
  """Chromosome class

  .. _chromosome_class:

  Args:
    chromosome_name (str): *required.* shorthand name of chromosome (often by number)
    chromosome_species (int): *required.* references :ref:`species_id <species_class>`

  Returns:
    Chromosome: instance of a chromosome
  """
  def __init__(self, chromosome_name, chromosome_species):
    self.n = chromosome_name
    self.s = chromosome_species


class variant(AutoRepr):
  """Variant class

  .. _variant_class:

  Args:
    variant_species (int): *required.* references :ref:`species_id <species_class>`
    variant_chromosome (int): *required.* references :ref:`chromosome_id <chromosome_class>`
    variant_pos (int): *required.* position of the variant allele on chromsome

  Returns:
    Variant: instance of a variant

  """
  def __init__(self, variant_species, variant_chromosome, variant_pos):
    self.s = variant_species
    self.c = variant_chromosome
    self.p = variant_pos


class genotype(AutoRepr):
  """Genotype class

  .. _genotype_class:

  Args:
    genotype_line (int): *required.* 
    genotype_chromosome (int): *required.* 
    genotype (tinyint[]): *required.* array of allele calls. Example value ``{0,0,0,-1,-1, ..., 0,0,0,0,2}``
    :comment: 
      .. container::
          :name: Details on genotype

          Example of possible 
          ``{0,0,0,-1,-1, ..., 0,0,0,0,2}``

          Each cell of the array contains an encoded value for allele call, and its meaing depends on the type of algorithm used. `Additional information on variant call format <https://en.wikipedia.org/wiki/Variant_Call_Format>`_. It's safe to assume that a value of ``-1`` is a missing call. Each value was generated by `vcftools <https://vcftools.github.io/man_latest.html>`_.
          At the time of authorship, the files used to generate them can be found on ``apollo`` at ``/shares/ibaxter_share/gziegler/Maize282_upliftedAGPv4``.
  
  Returns:
    Genotype: instance of a genotype
  """
  def __init__(self, genotype_line, genotype_chromosome, genotype, genotype_version):
    self.l = genotype_line
    self.c = genotype_chromosome
    self.g = genotype
    self.v = genotype_version

  def __repr__(self):
    # return "<%s: {%s}>" % (self.__class__.__name__, ', '.join(items))
    return "<%s: {%s}>" % (self.__class__.__name__, ', '.join([self.l, self.c, '*genotype*', self.v]))


class trait(AutoRepr):
  """Trait class

  .. _trait_class:

  Args:
    trait_name (str): *required.* name of trait
    measurement_unit (str): unit of measure
    measurement_device (str): name of measurement device used to record trait
    description (str): human-readable description of trait

  Returns:
    Trait: instance of a trait
  """
  def __init__(self, trait_name, measurement_unit, measurement_device, description):
    self.n = trait_name
    self.u = measurement_unit
    self.m = measurement_device
    self.d = description


class phenotype(AutoRepr):
  """Phenotype class

  .. _phenotype_class:


  Args:
    phenotype_line (int): *required.* references :ref:`line_id <line_class>`
    phenotype_trait (int): *required.* references :ref:`traid_id <trait_class>`
    phenotype_value (str): *required.*

  Returns:
    Phenotype: instance of a phenotype

  """
  def __init__(self, phenotype_line, phenotype_trait, phenotype_value):
    self.l = phenotype_line
    self.t = phenotype_trait
    self.v = str(phenotype_value)


class growout_type(AutoRepr):
  """Growout_Type class

  .. _growout_type_class:

  Args:
    growout_type (str): *required.* human-readable name of the type of medium used to grow plant

  Returns:
    Growout_Type: instance of a growout type

  """
  def __init__(self, growout_type):
    self.t = growout_type


class growout(AutoRepr):
  """Growout class

  .. _growout_class:

  Args:
    growout_name (str): *required.* coded name of growout. It seems to be a two-initial code for state or country and last two digits of the year
    growout_population (int): *required.* references :ref:`population_id <population_class>`
    growout_location (int): references :ref:`location_id <location_class>`
    year (int): *required.*
    growout_growout_type (int): *required.* references :ref:`growout_type_id <growout_type_class>`

  Returns:
    Growout: instance of a growout
  """
  def __init__(self, growout_name, growout_population, growout_location, year, growout_growout_type):
    self.n = growout_name
    self.p = growout_population
    self.l = growout_location
    self.y = year
    self.t = growout_growout_type


class location(AutoRepr):
  """Location class

  .. _location_class:

  Args:
    country (str): *required*.
    state (str):
    city (str):
    code (str): *required.* Two character code for location

  Returns:
    Location: instance of a location
  """
  def __init__(self, country, state, city, code):
    self.c = country
    self.s = state
    self.i = city
    self.o = code


class gwas_algorithm(AutoRepr):
  """:abbr:`GWAS(Genome-wide association studies)` algorithm class

  .. _gwas_algorithm_class:

  Args:
    gwas_algorithm (str): 
  
  Returns:
    GWAS_Algorithm: instance of a GWAS algorithm

  """
  def __init__(self, gwas_algorithm):
    self.a = gwas_algorithm


class genotype_version(AutoRepr):
  """Genotype Version class

  .. _genotype_version_class:

  Args:
    genotype_version_name (str): *required.*
    genotype_version (str): *required.* 
    reference_genome (int): *required.* references :ref:`line_id <line_class>`
    genotype_version_population (int): *required.* references :ref:`population_id <population_class>`

  Returns:
    Genotype_Version: instance of a genotype version
  """
  def __init__(self, genotype_version_name, genotype_version, reference_genome, genotype_version_population):
    self.n = genotype_version_name
    self.v = genotype_version
    self.r = reference_genome
    self.p = genotype_version_population


class imputation_method(AutoRepr):
  """Imputation Method class

  .. _imputation_method_class:

  Args:
    imputation_method (str): *require.* type of imputation used

  Returns:
    Imputation_Method: instance of an imputation method

  .. note::
    Need additional information on
    - imputation method (What is imputation?)

  """
  def __init__(self, imputation_method):
    self.m = imputation_method


class kinship_algorithm(AutoRepr):
  """Kinship Algorithm class

  .. _kinship_algorithm_class:

  Args:
    kinship_algorithm (str): *required.* name of algorithm

  Returns:
    Kinship_Algorithm: instance of a kinship algorithm
  """
  def __init__(self, kinship_algorithm):
    self.a = kinship_algorithm


class kinship(AutoRepr):
  """Kinship class

  .. _kinship_class:

  Args:
    kinship_algorithm (int): *required.* references :ref:`kinship_algorithm_id <kinship_algorithm>`
    kinship_file_path (str): *required.* local path to kinship file
    :comment: The file path is local to the machine running the database. Example path: ``/opt/BaxDB/file_storage/kinship_files/4.AstleBalding.synbreed.kinship.csv``

  Returns:
    Kinship: instance of a kinship

  """
  def __init__(self, kinship_algorithm, kinship_file_path):
    self.a = kinship_algorithm
    self.p = kinship_file_path

class population_structure_algorithm(AutoRepr):
  """Population Structure Algorithm class

  .. _population_structure_algorithm_class:

  Args:
    population_structure_algorithm (str): *required.* human-readable name for algorithm
  
  Returns:
    Population_Structure_Altgorithm: instance of a population structure algorithm
  """
  def __init__(self, population_structure_algorithm):
    self.a = population_structure_algorithm

class population_structure(AutoRepr):
  """Population Stucture class

  .. _population_structure_class:

  Args:
    population_structure_algorithm (int): *required* references :ref:`population_structure_algorithm_id <population_structure_algorithm_class>`
    population_structure_file_path (str): *required.* local path to population structure algorithm file
    :comment: The file path is local to the machine running the database. Example path: ``/opt/BaxDB/file_storage/population_structure_files/4.Eigenstrat.population.structure.10PCs.csv``
  
  Returns:
    Poputation_Structure: instance of a population structure
  
  """
  def __init__(self, population_structure_algorithm, population_structure_file_path):
    self.a = population_structure_algorithm
    self.p = population_structure_file_path

class gwas_run(AutoRepr):
  """:abbr:`GWAS(Genome-wide association studies)` Run class

  .. _gwas_run_class:

  Args:
    gwas_run_trait (int): *required.* references :ref:`trait_id <trait_class>`
    nsnps (int): *required.* number of SNPs that were included in the  GWAS run, this may be fewer than those available in the data set
    nlines (int): *required.* number of lines that were included in the GWAS run, this may be fewer than those available in the data set
    gwas_run_gwas_algorithm (int): *required.* references :ref:`gwas_algorithm_id <gwas_algorithm_class>`
    gwas_run_genotype_version (int): *required.* references :ref:`genotype_version_id <genotype_version_class>`
    missing_snp_cutoff_value (numeric): *required.* SNP cutoff value for 
    missing_line_cutoff_value (numeric): *required.*
    minor_allele_frequency_cutoff_value (numeric): *required.*
    gwas_run_imputation_method (int): *required.* references :ref:`imputation_method_id <imputation_method_class>`
    gwas_run_kinship (int): *required.* references :ref:`kinship_id <kinship_class>`
    gwas_run_population_structure (int): *required.* references :ref:`population_structure_id <population_structure_class>`

  Returns:
    GWAS_Run: instance of a GWAS run

  .. note::
    Needs additional information on
      - nsnps
      - nllines
      - snp cutoff value
      - line cutoff value
      - allele frequency cutoff value

  """
  def __init__(self, gwas_run_trait, nsnps, nlines, gwas_run_gwas_algorithm, gwas_run_genotype_version, missing_snp_cutoff_value, missing_line_cutoff_value, minor_allele_frequency_cutoff_value, gwas_run_imputation_method, gwas_run_kinship, gwas_run_population_structure):
    self.t = gwas_run_trait
    self.s = nsnps
    self.l = nlines
    self.a = gwas_run_gwas_algorithm
    self.v = gwas_run_genotype_version
    self.m = missing_snp_cutoff_value
    self.i = missing_line_cutoff_value
    self.n = minor_allele_frequency_cutoff_value
    self.p = gwas_run_imputation_method
    self.k = gwas_run_kinship
    self.o = gwas_run_population_structure

    # Initialize a dictionary version of the object for iteration
    self.d = {}
    attributes = [ 't','s','l','a','v','m','i','n','p','k','o' ]
    for a in range(len(attributes)):
      self.d[a] = getattr(self, attributes[a])

  # Adding an iterator to allow me to replace None values with NULL for
  # converting from Python object to SQL statements
  def __iter__(self):
    for key,item in self.d.items():
      yield key,item

  def keys(self):
    return self.d.keys()

  def items(self):
    return self.d.items()

  def values(self):
    return self.d.values()

class gwas_result(AutoRepr):
  """:abbr:`GWAS(Genome-wide association studies)` Resultf class

  .. _gwas_result_class:

  Args:
    gwas_result_chromosome (int): *required.*
    basepair (int): *required.*
    gwas_result_gwas_run (int): *required.*
    pval (numeric):
    cofactor (numeric):
    _order (numeric):
    null_pval (numeric):
    model_added_pval (numeric):
    model (str):
    pcs (int):

  Returns:
    GWAS_Result: instance of a GWAS result

  .. note::
    Needs additional information on the
      - basepair (possible the number of bps, but of what? the chromosome or the snp, or what?)
      - pval (is this significance *p-value*?)
      - cofactor (???)
      - _order (???)
      - null_pval (is there a *p-value* for a null hypothesis?)
      - model_added_pval (???)
      - model (is this a call of models used? Where is a list?)
      - pcs (???) - in the Maize282, there are 18 different permutations of the pcs, comprised of 1-3 integers. Are they the chromosome found significant?

  """
  def __init__(self,
               gwas_result_chromosome,
               basepair,
               gwas_result_gwas_run,
               pval,
               cofactor,
               _order,
               null_pval,
               model_added_pval,
               model,
               pcs):
    self.c = gwas_result_chromosome
    self.b = basepair
    self.r = gwas_result_gwas_run
    self.p = pval
    self.o = cofactor
    self.d = _order
    self.n = null_pval
    self.a = model_added_pval
    self.m = model
    self.s = pcs
